# Includes the global template required for deployment announcing
include:
  - project: templates/gitlab-templates
    file: sorush.gitlab-ci.yml

image: registry.snapp.tech/docker/golang:1.11.4-alpine3.8

stages:
  - pre-compile
  - compile
  - test
  - build
  - release
  - deploy

variables:
  BUILD_PATH: "./"
  OKD_TEH1_CLUSTER_ADDRESS: "okd.private.teh-1.snappcloud.io"
  OKD_TEH2_CLUSTER_ADDRESS: "okd.private.teh-2.snappcloud.io"
  OKD_TEH1_REGISTRY: 'registry.apps.private.teh-1.snappcloud.io'
  OKD_TEH2_REGISTRY: 'registry.apps.private.teh-2.snappcloud.io'
  PROJECT_SERVICE_NAME: 'soteria'
  PROJECT_STAGING: 'realtime-staging'
  PROJECT_PRODUCTION_TEH1: 'realtime-production'
  PROJECT_PRODUCTION_TEH2: 'rtc'
  PROJECT_MOZART: 'mozart'
  PROJECT_VERSION: "${CI_COMMIT_SHA}"


code-generator:
  stage: pre-compile
  image:
    name: namely/protoc-all
    entrypoint: [""]
  script:
    - entrypoint.sh -d ./web/grpc/contracts -l go -o ./web/grpc/contracts --with-gateway
  artifacts:
    paths:
      - ./web/grpc/contracts
    expire_in: 1 week
#  cache:
#    paths:
#      - ./web/grpc/contracts

.go_mod_config: &go_mod
  image: registry.snapp.tech/docker/golang:1.13.5-alpine3.10
  cache:
    policy: pull
    paths:
      - vendor/
  before_script:
    - go env -w GOPROXY="https://repo.snapp.tech/repository/goproxy/"

compile:
  <<: *go_mod
  stage: compile
  variables:
    GOOS: "linux"
    GOARCH: "amd64"
    CGO_ENABLED: 0
  script:
    - go mod vendor -v
    - go build -mod vendor -v -o ${BUILD_PATH}/${CI_PROJECT_NAME} cmd/soteria/soteria.go
  artifacts:
    name: "$CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG"
    paths:
      - ${BUILD_PATH}/${CI_PROJECT_NAME}
    expire_in: 1 week

unit_tests:
  <<: *go_mod
  stage: test
  coverage: '/total:\s*\(statements\)\s*([\d.]+)%/'
  script:
    - go test -gcflags=-l -v -coverprofile .coverage.out.tmp ./...
    - cat .coverage.out.tmp | grep -v "mock.go" > .coverage.out
    - rm -rf .coverage.out.tmp
    - go tool cover -func .coverage.out
  dependencies:
    - code-generator
    - compile


build:
  image: docker:latest
  stage: build
  variables:
    HTTP_PROXY: ${SNAPP_HTTP_PROXY}
    HTTPS_PROXY: ${SNAPP_HTTPS_PROXY}
    no_proxy: ${SNAPP_NOPROXY}
  script:
    - export CURRENT_DATETIME=$(TZ=Asia/Tehran date '+%FT%T')
    - docker build --build-arg BUILD_DATE=$CURRENT_DATETIME --build-arg VCS_REF=${CI_COMMIT_SHA} --build-arg BUILD_VERSION=${CI_COMMIT_REF_SLUG} -t ${CI_PROJECT_NAME}:${CI_COMMIT_REF_SLUG} .
  after_script:
    - docker save -o ${CI_PROJECT_NAME}-${CI_COMMIT_REF_SLUG}.tar ${CI_PROJECT_NAME}:${CI_COMMIT_REF_SLUG}
  artifacts:
    name: "docker-image-$CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG"
    paths:
      - ${CI_PROJECT_NAME}-${CI_COMMIT_REF_SLUG}.tar
    expire_in: 1 week
  dependencies:
    - code-generator
    - compile


.release_template: &release_job_definition
  image: docker:latest
  stage: release
  before_script:
    - docker info
    - docker login -u ${CONTAINER_REGISTRY_USERNAME} -p ${CONTAINER_REGISTRY_PASSWORD} ${CONTAINER_REGISTRY_ADDRESS}
    - docker load --input ${CI_PROJECT_NAME}-${CI_COMMIT_REF_SLUG}.tar
    - docker tag ${CI_PROJECT_NAME}:${CI_COMMIT_REF_SLUG} ${CONTAINER_REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}
  script:
    - docker push ${CONTAINER_REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}
  dependencies:
    - build


release:staging:
  <<: *release_job_definition
  variables:
    CONTAINER_REGISTRY_ADDRESS: "$OKD_TEH1_REGISTRY"
    CONTAINER_REGISTRY_IMAGE: "$OKD_TEH1_REGISTRY/$PROJECT_STAGING/$CI_PROJECT_NAME"
    CONTAINER_REGISTRY_USERNAME: "gitlab-ci"
    CONTAINER_REGISTRY_PASSWORD: "$OKD_STAGING_TOKEN"
  only:
    - master
    - tags
    - branches

release:mozart:
  <<: *release_job_definition
  variables:
    CONTAINER_REGISTRY_ADDRESS: "$OKD_TEH1_REGISTRY"
    CONTAINER_REGISTRY_IMAGE: "$OKD_TEH1_REGISTRY/$PROJECT_MOZART/$CI_PROJECT_NAME"
    CONTAINER_REGISTRY_USERNAME: "gitlab-ci"
    CONTAINER_REGISTRY_PASSWORD: "$OKD_MOZART_TOKEN"
  only:
    - master
    - tags
    - branches
  when: manual

release:production:teh-1:
  <<: *release_job_definition
  variables:
    CONTAINER_REGISTRY_ADDRESS: "$OKD_TEH1_REGISTRY"
    CONTAINER_REGISTRY_IMAGE: "$OKD_TEH1_REGISTRY/$PROJECT_PRODUCTION_TEH1/$CI_PROJECT_NAME"
    CONTAINER_REGISTRY_USERNAME: "gitlab-ci"
    CONTAINER_REGISTRY_PASSWORD: "$OKD_PRODUCTION_TOKEN_TEH1"
  only:
    - tags

release:production:teh-2:
  <<: *release_job_definition
  variables:
    CONTAINER_REGISTRY_ADDRESS: "$OKD_TEH2_REGISTRY"
    CONTAINER_REGISTRY_IMAGE: "$OKD_TEH2_REGISTRY/$PROJECT_PRODUCTION_TEH2/$CI_PROJECT_NAME"
    CONTAINER_REGISTRY_USERNAME: "gitlab-ci"
    CONTAINER_REGISTRY_PASSWORD: "$OKD_PRODUCTION_TOKEN_TEH2"
  only:
    - tags



.deploy_template: &deploy_job_definition
  image: openshift/origin-cli:v3.10
  stage: deploy
  before_script:
    - oc version
    - oc login https://${DEPLOY_ADDRESS} --token=${DEPLOY_TOKEN}
    - oc project ${DEPLOY_PROJECT}
    -  - oc process -f .okd/DeploymentConfig.yaml --param APP_IMAGE=${CONTAINER_REGISTRY_IMAGE} --param SERVICE_NAME=${DEPLOY_SERVICE_NAME} | oc apply -f -
    - |
      oc process -f .okd/ConfigMap.yaml \
        --param SERVICE_NAME="${DEPLOY_SERVICE_NAME}" \
        --param APP_VERSION="${PROJECT_VERSION}" \
        --param REDIS_ADDR="${DEPLOY_REDIS_ADDR}" \
        --param REDIS_PASS="${DEPLOY_REDIS_PASS}" \
        --param CI_COMMIT_REF_SLUG="${CI_COMMIT_REF_SLUG}" | oc apply -f -
    - |
      oc process -f .okd/Secret.yaml \
        --param SERVICE_NAME="${DEPLOY_SERVICE_NAME}" \
        --param APP_VERSION="${PROJECT_VERSION}" \
        --param CI_COMMIT_REF_SLUG="${CI_COMMIT_REF_SLUG}" \
        --param PASSENGER_HASH_SALT="${DEPLOY_PASSENGER_SALT}" \
        --param PASSENGER_HASH_LENGTH=15 \
        --param DRIVER_HASH_SALT="${DEPLOY_DRIVER_SALT}" \
        --param DRIVER_HASH_LENGTH=15 \
        --param DRIVER_JWT_PUBLIC_KEY="${DEPLOY_DRIVER_JWT_PUBLIC_KEY}" \
        --param PASSENGER_JWT_PUBLIC_KEY="${DEPLOY_PASSENGER_JWT_PUBLIC_KEY}" \
        --param THIRD_PARTY_JWT_PUBLIC_KEY="${DEPLOY_THIRD_PARTY_JWT_PUBLIC_KEY}" \
        --param THIRD_PARTY_JWT_PRIVATE_KEY="${DEPLOY_THIRD_PARTY_JWT_PRIVATE_KEY}" | oc apply -f -
    - |
      oc process -f .okd/AutoScaler.yaml \
        --param MIN_REPLICA=${DEPLOY_MIN_REPLICA} \
        --param MAX_REPLICA=${DEPLOY_MAX_REPLICA} \
        --param CPU_UTILIZATION=${DEPLOY_CPU_UTILIZATION} | oc apply -f -
    - oc process -f .okd/Route.yaml --param APP_HOST=${DEPLOY_SERVICE_NAME} --param SERVICE_NAME=${DEPLOY_SERVICE_NAME} | oc apply -f -
    - oc process -f .okd/Service.yaml --param SERVICE_NAME=${DEPLOY_SERVICE_NAME} | oc apply -f -
  script:
    - oc rollout latest dc/${DEPLOY_SERVICE_NAME}
  only:
    - tags
  when: manual

deploy:staging:teh_1:
  <<: *deploy_job_definition
  variables:
    DEPLOY_MIN_REPLICA: "1"
    DEPLOY_MAX_REPLICA: "2"
    DEPLOY_CPU_UTILIZATION: "80"
    CONTAINER_REGISTRY_IMAGE: "$PROJECT_STAGING/${PROJECT_SERVICE_NAME}:$CI_COMMIT_REF_SLUG"
    DEPLOY_ADDRESS: "${OKD_TEH1_CLUSTER_ADDRESS}"
    DEPLOY_PROJECT: "${PROJECT_STAGING}"
    DEPLOY_TOKEN: "${OKD_STAGING_TOKEN}"
    DEPLOY_PASSENGER_SALT: "${PASSENGER_SALT_DEV}"
    DEPLOY_DRIVER_SALT: "${DRIVER_SALT_DEV}"
    DEPLOY_SERVICE_NAME: "${PROJECT_SERVICE_NAME}-staging"
    DEPLOY_DRIVER_JWT_PUBLIC_KEY: "${DRIVER_JWT_PUBLIC_KEY_MOZART}"
    DEPLOY_PASSENGER_JWT_PUBLIC_KEY: "${PASSENGER_JWT_PUBLIC_KEY_MOZART}"
    DEPLOY_THIRD_PARTY_JWT_PUBLIC_KEY: "${THIRD_PARTY_JWT_PUBLIC_KEY_MOZART}"
    DEPLOY_THIRD_PARTY_JWT_PRIVATE_KEY: "${THIRD_PARTY_JWT_PRIVATE_KEY_MOZART}"
    DEPLOY_REDIS_ADDR: "soteria-redis-haproxy:6379"
  only:
    - master
    - branches
  needs: ["release:staging"]

deploy:production:teh_1:
  <<: *deploy_job_definition
# Extends the global template so it add an after_script step for deployment announcement
  extends: .deployments_after_script
  variables:
    DEPLOY_MIN_REPLICA: "3"
    DEPLOY_MAX_REPLICA: "20"
    DEPLOY_CPU_UTILIZATION: "65"
    CONTAINER_REGISTRY_IMAGE: "$PROJECT_PRODUCTION_TEH1/$PROJECT_SERVICE_NAME:$CI_COMMIT_REF_SLUG"
    DEPLOY_ADDRESS: "${OKD_TEH1_CLUSTER_ADDRESS}"
    DEPLOY_PROJECT: "${PROJECT_PRODUCTION_TEH1}"
    DEPLOY_TOKEN: "${OKD_PRODUCTION_TOKEN_TEH1}"
    DEPLOY_PASSENGER_SALT: "${PASSENGER_SALT_PRODUCTION}"
    DEPLOY_DRIVER_SALT: "${DRIVER_SALT_PRODUCTION}"
    DEPLOY_SERVICE_NAME: "${PROJECT_SERVICE_NAME}"
    DEPLOY_DRIVER_JWT_PUBLIC_KEY: "${DRIVER_JWT_PUBLIC_KEY_PRODUCTION}"
    DEPLOY_PASSENGER_JWT_PUBLIC_KEY: "${PASSENGER_JWT_PUBLIC_KEY_PRODUCTION}"
    DEPLOY_THIRD_PARTY_JWT_PUBLIC_KEY: "${THIRD_PARTY_JWT_PUBLIC_KEY_PRODUCTION}"
    DEPLOY_THIRD_PARTY_JWT_PRIVATE_KEY: "${THIRD_PARTY_JWT_PRIVATE_KEY_PRODUCTION}"
    DEPLOY_REDIS_ADDR: "soteria-redis-haproxy.realtime-production.svc:6379"
    CI_DEPLOYMENT_INFRA: "teh-1"
  needs: ["release:production:teh-1"]

deploy:production:teh_2:
  <<: *deploy_job_definition
# Extends the global template so it add an after_script step for deployment announcement
  extends: .deployments_after_script
  variables:
    DEPLOY_MIN_REPLICA: "3"
    DEPLOY_MAX_REPLICA: "20"
    DEPLOY_CPU_UTILIZATION: "70"
    CONTAINER_REGISTRY_IMAGE: "$PROJECT_PRODUCTION_TEH2/$PROJECT_SERVICE_NAME:$CI_COMMIT_REF_SLUG"
    DEPLOY_ADDRESS: "${OKD_TEH2_CLUSTER_ADDRESS}"
    DEPLOY_PROJECT: "${PROJECT_PRODUCTION_TEH2}"
    DEPLOY_TOKEN: "${OKD_PRODUCTION_TOKEN_TEH2}"
    DEPLOY_PASSENGER_SALT: "${PASSENGER_SALT_PRODUCTION}"
    DEPLOY_DRIVER_SALT: "${DRIVER_SALT_PRODUCTION}"
    DEPLOY_SERVICE_NAME: "${PROJECT_SERVICE_NAME}"
    DEPLOY_DRIVER_JWT_PUBLIC_KEY: "${DRIVER_JWT_PUBLIC_KEY_PRODUCTION}"
    DEPLOY_PASSENGER_JWT_PUBLIC_KEY: "${PASSENGER_JWT_PUBLIC_KEY_PRODUCTION}"
    DEPLOY_THIRD_PARTY_JWT_PUBLIC_KEY: "${THIRD_PARTY_JWT_PUBLIC_KEY_PRODUCTION}"
    DEPLOY_THIRD_PARTY_JWT_PRIVATE_KEY: "${THIRD_PARTY_JWT_PRIVATE_KEY_PRODUCTION}"
    DEPLOY_REDIS_ADDR: "soteria-redis-haproxy.realtime-production.svc:6379"
    CI_DEPLOYMENT_INFRA: "teh-2"
  needs: ["release:production:teh-2"]

deploy:production:vm:
# Extends the global template so it add an after_script step for deployment announcement
  extends: .deployments_after_script
  image: registry.snapp.tech/docker/deployer:alpine3.11
  stage: deploy
  parallel: 5
  variables:
# Add a variable to specify where deployment will be happened for announcement
    CI_DEPLOYMENT_INFRA: "Afranet"
    DEPLOYER_PRIVATE_KEY: ${DEPLOYER_PRIVATE_KEY}
    APP_HOSTNAME: "emqx-0${CI_NODE_INDEX}.app.afra.snapp.infra"
  before_script:
    - tar -C ${BUILD_PATH} -cvzf "artifacts-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA.tar.gz" ${CI_PROJECT_NAME}
  script:
    - chmod +x ./.gitlab/ci/scripts/deploy.sh
    - echo  "Deploy Soteria-0${CI_NODE_INDEX}"
    - ./.gitlab/ci/scripts/deploy.sh
  needs: ["compile"]
  rules:
    - if: "$CI_COMMIT_BRANCH && $UPDATE_ENVIRONMENT_VARIABLE == null "
    - if: '$CI_COMMIT_TAG'
      when: manual

deploy:env:
  image: registry.snapp.tech/docker/deployer:alpine3.11
  stage: deploy
  parallel: 5
  variables:
    DEPLOYER_PRIVATE_KEY: ${DEPLOYER_PRIVATE_KEY}
  script:
    - chmod +x .gitlab/ci/scripts/update-environments.sh
    - echo  "Update ENV Soteria-0${DEPLOYER_PRIVATE_KEY}"
    - .gitlab/ci/scripts/update-environments.sh 
    - chmod +x .gitlab/ci/scripts/notify-eye.sh
    - echo  "Send notif to Dispatching-alert room ..."
    - .gitlab/ci/scripts/notify-eye.sh   
  needs: ['compile']
  only:
    - tag
  when: manual

update:env:
  image: registry.snapp.tech/docker/deployer:alpine3.11
  stage: deploy
  parallel: 5
  variables:
    DEPLOYER_PRIVATE_KEY: ${DEPLOYER_PRIVATE_KEY}
  script:
    - chmod +x .gitlab/ci/scripts/update-environments.sh
    - echo  "Update ENV Soteria-0${DEPLOYER_PRIVATE_KEY}"
    - .gitlab/ci/scripts/update-environments.sh 
    - chmod +x .gitlab/ci/scripts/notify-eye.sh
    - echo  "Send notif to Dispatching-alert room ..."
    - .gitlab/ci/scripts/notify-eye.sh  
  rules:
    - if: '$UPDATE_ENVIRONMENT_VARIABLE == "true"'
      when: manual
